\documentclass[12pt, a4paper, oneside]{article}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{placeins}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{bussproofs}
\usepackage{xparse}

\usepackage[toc,page]{appendix}

\newcommand{\stepsto}{\Downarrow}
\newcommand{\hoare}[3]{
	 $\left\langle #1 \right\rangle   #2 \left\langle #3 \right\rangle$
}
% font size could be 10pt (default), 11pt or 12 pt
% paper size coulde be letterpaper (default), legalpaper, executivepaper,
% a4paper, a5paper or b5paper
% side coulde be oneside (default) or twoside 
% columns coulde be onecolumn (default) or twocolumn
% graphics coulde be final (default) or draft 
%
% titlepage coulde be notitlepage (default) or titlepage which 
% makes an extra page for title 
% 
% paper alignment coulde be portrait (default) or landscape 
%
% equations coulde be 
%   default number of the equation on the rigth and equation centered 
%   leqno number on the left and equation centered 
%   fleqn number on the rigth and  equation on the left side
%   

\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-10mu+}}}

\newcommand{\sproof}{
  \scriptsize
  \begin{center}
  \begin{prooftree}
  \def\defaultHypSeparation{\hskip .1in}
% whats that doing? ->  \def\fCenter{\models}
}

\newcommand{\eproof}{
  \end{prooftree}
  \end{center}
  \normalsize
}

\DeclareDocumentCommand{\sstepe}{m m m m} {%
  \ensuremath{{#1} \vdash \text{{#3}} \; \rightarrow \; {#2} \vdash \text{{#4}}}%
}
\DeclareDocumentCommand{\sstep}{O{} O{} m m} {%
  \sstepe{\Phi_{#1}}{\Phi_{#2}}{#3}{#4}%
}



\title{TPT Project (TODO add desc)}
\author{Marco Vassena  \\
    4110161 \\
    \and
    Philipp Hausmann \\
    4003373 \\
    \and
    Ondra Pelech \\
    F131636 \\
    }

\date{\today}
\begin{document}



\maketitle

\tableofcontents


\section{Research question}
Defining a formal semantics for a small arithmetic language is straightforward. In this project, we aimed to enrich such a minimal programming language with a mutable heap, defining and formalizing its semantics. Adding mutable, global state makes the language impure, which  poses a number of problems and issues, such as threading the heap throughout the evaluation of a term and dealing with invalid references to the heap. 
We managed to solve these problems and reached our goals. Furthermore we have successfully embedded hoare logic in the language, allowing to reason about the correctness of a program written in this minimal programming language.

\subsection{Overview}
In section~\ref{sec:method} we show different alternative approaches to solve the problem and their restrictions. 
In section \ref{sec:cont} we define the formal semantics in Agda for one such approach.
Section~\ref{sec:metatheories} lists the theoretical results proved and in~\ref{sec:hoare} the embedding of hoare logic is explained.
Finally in~\ref{sec:conclusion} we draw our conclusions about the project, compare it to the languages studied during the course and propose few ideas for future work.

\section{Research Method}
\label{sec:method}
Designing a suitable language to study the semantics of a mutable heap is not inherently complex, but influences greatly
the ability to prove things. Therefor the choice of language has to be done careful, and we identified two
major aspects defining any such language.

\subsection{Totality}
The first aspect is whether our language is total or not. A language shall be total if all evalutions
are always guaranteed to succeed. A language is non-total, if the evaluation of a term might fail or not terminate at runtime.

\paragraph{Total version}
Having a total language on one hand simplifies proofs in that it reduces the number of possible evaluations.
On the other hand, it requires that we can guarantee the totality of the language in the proofs. This turned
out to be rather difficult.

This proof can be encoded in Agda by adding a heap description object which we call \emph{shape}. The shape
describes the cells of the heap and can be used to guarantee the success of a heap access. The design
is very similar to the Context/Environment design used in the Simply Typed $\lambda$-Calculus
during the TPT lectures.

One source of problems was finding a suitable encoding of reference-values. To be able to relate the proof
objects stored inside a reference with the current heap, all references need to be indexed over the heap.
As references are part of the value domain, this implies that values need to be
indexed over the heap. While we are not aware of any insurmountable problem caused by this, it leads
to very verbose types in the whole program.

A similar issue occurs when storing references themselves on the heap is allowed. The reference
values on the heap now depend on the heap itself in their proof objects. Due to the different
versions of the heap involved this is unlikely to cause circular dependencies, but it increases
the complexity of the semantics and proofs greatly.
An easy solution to this problem is disallowing references on the heap. How this would influence
the semantics remains an open question.


Due to the complexities shown above, we did not succeed in defining and using a total
language in our setting. We have not found any unsolvable problem which would make
defining a total language impossible, but finding a suitable encoding in Agda
and proving properties of the semantics appears to be a hard problem nonetheless.


-TODO describe problems
-Value-Term conversions
-Refs in Heap?
-Proof propagation?


\paragraph{Partial version}
Using a non-total language on the other hand relieves the burden of guaranteeing totality.
Instead, the concept of failure now needs to be encoded either by defining a partial semantics
or by lifting the partiality to the language itself.

At first we tried to define a partial semantics, which unfortunately turned out to be fairly awkward and non-idiomatic. Proofs are limited only to the succeeding cases, which leads to verbose and error-prone proofs without gaining any benefit. 

Lifting the partiality to the language itself makes the semantics total again.
Handling errors appropriately is then a concern of the final user, which mimics the semantics of most widely used programming languages like C, Java, etc. in this regard.
The terms for the partial heap-approach can be seen in figure \ref{lst:part-term}.

\begin{figure}
\begin{lstlisting}
data Term : Type -> Set where
  new  : forall {ty} -> Term ty -> Term (Ref ty)
  !_   : forall {ty} -> Term (Ref ty) -> Term ty
  _:=_ : forall {ty} -> Term (Ref ty) -> Term ty -> Term ty
  ref  : forall {ty} -> Nat -> Term (Ref ty)
\end{lstlisting}
\caption{Terms for partial heap semantics}
\label{lst:part-term}
\end{figure}


\subsection{Host Language}
The second important choice is what other features apart from the heap itself the language will have. We will call this the \emph{Host Language} in the remainder of this report.


\paragraph{Simply Typed $\lambda$-Calculus}
Our first approach was to add a mutable heap to the Simply Typed $\lambda$-Calculus using a total semantics. We used the semantics discussed during the TPT lectures
as base for this experiment.

The combined complexity of the Simply Typed $\lambda$-Calculus itself together with the totality requirement prevented that a solution could be found in a useful timeframe.
How a partial semantics would work together with Simply Typed $\lambda$-Calculus has not been looked at, but we expect that our work on partial semantics for a simple
boolean/naturals language can be used as inspiration.

For further research we strongly recommend to first solve the problems in a simpler language and extend it later on.

\paragraph{BoolNat}
The BoolNat language contains only boolean expression and natural numbers.

\section{Partial BoolNat language}
\label{sec:boolnat}

Due to the problems encountered with the Simply Typed $\lambda$-Calculus and the totality requirement, we will focus on a partial BoolNat
language in the following chapters. To be more precise, it is a version of the BoolNat language extended with a try-catch construct and 
sequencing. The terms of the language can be seen in figure \ref{lst:part-boolnat-term}.

\begin{figure}
\begin{lstlisting}
data Term : Type -> Set where
  true          : Term Boolean
  false         : Term Boolean
  error         : forall {ty} -> Term ty 
  num           : Nat -> Term Natural
  iszero        : Term Natural -> Term Boolean
  if_then_else_ : forall {ty} -> (cond  : Term Boolean)
                              -> (tcase : Term ty)
                              -> (fcase : Term ty)
                              -> Term ty
  new           : forall {ty} -> Term ty -> Term (Ref ty)
  !_            : forall {ty} -> Term (Ref ty) -> Term ty
  _:=_          : forall {ty} -> Term (Ref ty) -> Term ty -> Term ty
  ref           : forall {ty} -> Nat -> Term (Ref ty)
  try_catch_    : forall {ty} -> Term ty -> Term ty -> Term ty
  _>>_          : forall {ty1 ty2} -> Term ty1 -> Term ty2 -> Term ty2
\end{lstlisting}
\caption{The terms of the partial BoolNat language.}
\label{lst:part-boolnat-term}
\end{figure}







		- Lambda calculus

		Challenges in modeling

			- Total language (valid references)

			- Function applications vs proof objects

			- Statement vs expression (hoare)


\section{Research contribution}
\label{sec:cont}
The language described in~\ref{sec:boolnat} has been implemented in Agda together with a small-step, big-step and denotational semantics.

\subsection{Properties}
\label{sec:metatheories}
The following meta-theories have been proved:
\begin{itemize}
	\item Progress
	\item Preservation
	\item Soundness
	\item Completeness
	\item Determinism
	\item Termination
	\item Type preservation in the heap
	\item Size preservation of the heap
\end{itemize}

Most of them are well-known properties of semantics. Those are proved mainly by case analyses and structural induction. By completeness and soundness follow that the big-step semantics is equivalent to the denotational semantics. At the moment the similar correspondence from small-step semantics and big-step semantics holds only in one direction. Nevertheless we expect it to hold as well, but because of the specific definitions used the proof is overly complicated, although not very interesting.

\paragraph{Type preservation in the heap}
This property states that when a cell of the heap is allocated, the type of the values that can be stored in that cell is fixed and cannot be changed. Although we did not use this property, we believe it could be useful in future work.

\paragraph{Size preservation of the heap}
This simple property states that the heap cannot shrink, but only grows.
In our language it is not possible to deallocate something from the heap.

\subsection{Hoare Logic}
\label{sec:hoare}
Hoare logic is a formal system used to reason about the correctness of a program. 
This is achieved using Hoare triples $\left\langle P \right\rangle   S \left\langle Q \right\rangle$, where $P$ and $Q$ are predicates over the state and $S$ is a program, which means that if $P$ holds in some initial state, and $P$ is evaluated leading to some other state, in this final state $Q$ holds.
We embedded this logic in our language and proved few inference rules so that it is actually possible to formally prove the correctness of a program written in our language.

\paragraph{Hoare Triples}
Hoare triples $ \left\langle P \right\rangle   S \left\langle Q \right\rangle$ have been modeled following the definition. The only differences is that the state in our  setting is the heap. In order to make triples more expressive the post condition is a predicate over not only the final heap, but also the value resulting from the evaluation of $S$.

\sproof
\AxiomC{$\vdash (P\ \Phi_0)$}
\AxiomC{$\Phi_0 \vdash S \Downarrow \Phi_1 \vdash v $}
\BinaryInfC{$\vdash (Q\ \Phi_1\ v)$}
\eproof
Where $\vdash (P\  \Phi_0)$ means that $P$ holds for the initial heap $\Phi_0$ and $\vdash (Q\ \Phi_1\ v)$ means that $Q$ holds for the final heap $\Phi_1$ and for the resulting value $v$.

Hoare triples come with two interpretations: total and partial.
When using partial interpretation the termination of the program is assumed whereas in total interpretation it is a proof obligation.
In our project we have provided either the interpretations, with the only difference that they refer to exceptions rather than non-termination.
The semantics of the language specifies that when an exception is raised the computation is aborted, therefore it is not possible to guarantee the post condition.
Partial interpretation is denoted by $ \left\langle P \right\rangle  S \left\langle Q \right\rangle^*$ :
\sproof
\AxiomC{$\vdash (P\ \Phi_0)$}
\AxiomC{$\Phi_0 \vdash S \Downarrow \Phi_1 \vdash v $}
\BinaryInfC{$\vdash \neg \texttt{fail} \Rightarrow (Q\ \Phi_1\ v)$}
\eproof
Where \texttt{fail} is true when $v$ is \texttt{verror}.

\section{Conclusion}

\subsection{Comparison}
Comparison with mini-languages used in the course.

\subsection{Future Work}
Extend hoare logic to fully cope with the statement vs expression issue (evaluation changes the heap) 

Complete the missing rules. 

Make the theorems for hoare logic more usable.



\begin{thebibliography}{1}

\bibitem{BP02}
  Benjamin C. Pierce.
  \emph{Types and Programming Languages}

\bibitem{BPSF}
	Benjamin C. Pierce.
	\emph{Software Foundations and Programming Languages}


\end{thebibliography}



\begin{appendices}

\section{Small-step Semantics}

\subsection{If then else}
\begin{itemize}

\item
If
\sproof
\AxiomC{\sstep[0][1]{t$_0$}{t$_0$'}}
\UnaryInfC{\sstep[0][1]{\textbf{if} t$_0$ \textbf{then} t$_1$ \textbf{else} t$_2$}{\textbf{if} t$_0$' \textbf{then} t$_1$ \textbf{else} t$_2$}}
\eproof

\item
IfTrue
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{if} \emph{true} \textbf{then} t \textbf{else} e}{t}}
\eproof

\item
IfFalse
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{if} \emph{false} \textbf{then} t \textbf{else} e}{e}}
\eproof

\item
IfErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{if} \emph{error} \textbf{then} t \textbf{else} e}{\emph{error}}}
\eproof

\end{itemize}


\subsection{Is zero?}
\begin{itemize}

\item
IsZero
\sproof
\AxiomC{\sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{\textbf{iszero} t}{\textbf{iszero} t'}}
\eproof

\item
IsZeroZero
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{iszero} (\emph{num} 0)}{\emph{true}}}
\eproof

\item
IsZeroSucc
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{iszero} (\emph{suc} v)}{\emph{false}}}
\eproof

\item
IsZeroErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{iszero} \emph{error}}{\emph{error}}}
\eproof

\end{itemize}


\subsection{References}
\begin{itemize}

\item
New
\sproof
\AxiomC{\sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{\textbf{new} t} {\textbf{new} t'}}
\eproof

\item
NewVal
\sproof
\AxiomC{t $\equiv$ $\ulcorner$ v $\urcorner$}
\UnaryInfC{\sstepe{\Phi}{\Phi \doubleplus \text{[v]}}{\textbf{new} t}{\emph{ref} (\underline{len} $\Phi$)}}
\eproof

\item
Deref
\sproof
\AxiomC{\sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{\textbf{!} t} {\textbf{!} t'}}
\eproof

\item
DerefVal
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{!} (\emph{ref} n)} {$\ulcorner$ \underline{lookup} n $\Phi$ $\urcorner$}}
\eproof

\item
DerefErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{!} \emph{error}} {\emph{error}}}
\eproof


\item
AssLeft
\sproof
\AxiomC{\sstep[0][1]{t$_1$}{t$_1$'}}
\UnaryInfC{\sstep[0][1]{t$_1$ \textbf{:=} t$_2$} {t$_1$' \textbf{:=} t$_2$}}
\eproof

\item
AssRight
\sproof
\AxiomC{$\neg$\underline{isError} v ~~ \sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{v \textbf{:=} t} {v \textbf{:=} t'}}
\eproof

\item
AssErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\emph{error} \textbf{:=} t} {\emph{error}}}
\eproof

\item
AssRed
\sproof
\AxiomC{t $\equiv$ $\ulcorner$ v $\urcorner$ ~~ rep : \textbf{Elem} $\Phi$ r}
\UnaryInfC{\sstepe{\Phi}{\text{\underline{replace}}~\Phi~\text{rep v}}
{(\emph{ref} r) \textbf{:=} t}{t}}
\eproof

\item
AssRedErr
\sproof
\AxiomC{$\neg$ \textbf{Elem} $\Phi$ r}
\UnaryInfC{\sstep{(\emph{ref} r) \textbf{:=} t} {\emph{error}}}
\eproof

\end{itemize}


\subsection{Sequencing}
\begin{itemize}

\item
Seq
\sproof
\AxiomC{\sstep[0][1]{t$_1$}{t$_1$'}}
\UnaryInfC{\sstep[0][1]{t$_1$ \textbf{$\gg$} t$_2$} {t$_1$' \textbf{$\gg$} t$_2$}}
\eproof

\item
SeqVal
\sproof
\AxiomC{$\neg$\underline{isError} v$_1$}
\UnaryInfC{\sstep{v$_1$ \textbf{$\gg$} t$_2$} {t$_2$}}
\eproof

\item
SeqErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\emph{error} \textbf{$\gg$} t} {\emph{error}}}
\eproof

\end{itemize}


\subsection{Try catch}
\begin{itemize}

\item
TryCatch
\sproof
\AxiomC{\sstep[0][1]{t$_1$}{t$_1$'}}
\UnaryInfC{\sstep[0][1]{\textbf{try} t$_1$ \textbf{catch} t$_2$} {\textbf{try} t$_1$' \textbf{catch} t$_2$}}
\eproof

\item
TryCatchSucc
\sproof
\AxiomC{$\neg$\underline{isError} v$_1$}
\UnaryInfC{\sstep{\textbf{try} v$_1$ \textbf{catch} t$_2$} {v$_1$}}
\eproof

\item
TryCatchFail
\sproof
\AxiomC{\underline{isError} t$_1$}
\UnaryInfC{\sstep{\textbf{try} t$_1$ \textbf{catch} t$_2$} {t$_2$}}
\eproof

\end{itemize}



\section{Big-step Semantics}

\subsection{Values}

\begin{itemize}

\item
True
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{true} ~$\stepsto$~ $\Phi \vdash$ \emph{vtrue}}
\eproof

\item
False
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{false} ~$\stepsto$~ $\Phi \vdash$ \emph{vfalse}}
\eproof

\item
Num
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{num} m ~$\stepsto$~ $\Phi \vdash$ \emph{vnum} m}
\eproof

\item
Ref
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{ref} r ~$\stepsto$~ $\Phi \vdash$ \emph{vref} r}
\eproof

\item
Error
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{error} ~$\stepsto$~ $\Phi \vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{If then else}

\begin{itemize}

\item
IfTrue
\sproof
\AxiomC{$\Phi_1 \vdash$ c ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vtrue}}
\AxiomC{$\Phi_2 \vdash$ t ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{if} c \textbf{then} t \textbf{else} e ~$\stepsto$~ $\Phi_3 \vdash$ v}
\eproof

\item
IfFalse
\sproof
\AxiomC{$\Phi_1 \vdash$ c ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vfalse}}
\AxiomC{$\Phi_2 \vdash$ e ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{if} c \textbf{then} t \textbf{else} e ~$\stepsto$~ $\Phi_3 \vdash$ v}
\eproof

\item
IfErr
\sproof
\AxiomC{$\Phi_1 \vdash$ c ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{if} c \textbf{then} t \textbf{else} e ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{Is zero?}

\begin{itemize}

\item
IsZeroZ
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vnat 0}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{isZero} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vtrue}}
\eproof

\item
IsZeroS
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vnat (succ} n \emph{)}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{isZero} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vfalse}}
\eproof

\item
IsZeroErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{isZero} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{References}

\begin{itemize}

\item
New
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ v}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{new} t ~$\stepsto$~ $\Phi_2 \doubleplus$ [v] $\vdash$ \emph{vref} (\underline{len} $\Phi_2$)}
\eproof

\item
Deref
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vref} r}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{!} t ~$\stepsto$~ $\Phi_2 \vdash$ \underline{lookup} r $\Phi_2$}
\eproof

\item
DerefErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{!} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\eproof

\item
Ass
\sproof
\AxiomC{rep : \textbf{Elem} $\Phi_3$ r ~~ $\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vref} r}
\AxiomC{$\Phi_2 \vdash$ t$_2$ ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{:=} t$_2$ ~$\stepsto$~ \underline{replace} $\Phi_3$ rep v $\vdash$ v}
\eproof

\item
AssOob
\sproof
\AxiomC{$\neg$ \textbf{Elem} $\Phi_3$ r}
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vref} r}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{:=} t$_2$ ~$\stepsto$~ $\Phi_2$ $\vdash$ \emph{verror}}
\eproof

\item
AssErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{:=} t$_2$ ~$\stepsto$~ $\Phi_2$ $\vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{Sequencing}

\begin{itemize}

\item
Seq
\sproof
\AxiomC{$\neg$ \textbf{isVError} v$_1$ ~~ $\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ v$_1$}
\AxiomC{$\Phi_2 \vdash$ t$_2$ ~$\stepsto$~ $\Phi_3 \vdash$ v$_2$}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{$\gg$} t$_2$ ~$\stepsto$~ $\Phi_3$ $\vdash$ v$_2$}
\eproof

\item
SeqErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{$\gg$} t$_2$ ~$\stepsto$~ $\Phi_3$ $\vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{Try catch}

\begin{itemize}

\item
TryCatch
\sproof
\AxiomC{$\neg$ \textbf{isVError} v$_1$}
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{try} t$_1$ \textbf{catch} t$_2$ ~$\stepsto$~ $\Phi_2$ $\vdash$ v}
\eproof

\item
TryCatchErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{$\Phi_2 \vdash$ t$_2$ ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{try} t$_1$ \textbf{catch} t$_2$ ~$\stepsto$~ $\Phi_3$ $\vdash$ v}
\eproof

\end{itemize}

\section{Hoare Rules}
\begin{itemize}

\item Precondition strengthening
\sproof
\AxiomC{$\models P \Rightarrow P'$}
\AxiomC{\hoare{P'}{S}{Q}}
\BinaryInfC{\hoare{P}{S}{Q}}
\eproof

\item Post condition weakening
\sproof
\AxiomC{$\models Q' \Rightarrow Q$}
\AxiomC{\hoare{P}{S}{Q'}}
\BinaryInfC{\hoare{P}{S}{Q}}
\eproof

\item Conjunction
\sproof
\AxiomC{\hoare{P1}{S}{Q1}}
\AxiomC{\hoare{P2}{S}{Q2}}
\BinaryInfC{\hoare{P1 \wedge P2}{S}{Q1 \wedge Q2}}
\eproof

\item Disjunction
\sproof
\AxiomC{\hoare{P1}{S}{Q1}}
\AxiomC{\hoare{P2}{S}{Q2}}
\BinaryInfC{\hoare{P1 \vee P2}{S}{Q1 \vee Q2}}
\eproof

\item If-Then-Else ($S$ expression)

\sproof
\AxiomC{\hoare{P \wedge g}{S1}{Q}}
\AxiomC{\hoare{P \wedge \neg g}{S2}{Q}}
\BinaryInfC{\hoare{P}{\texttt{if}\ g\ \texttt{then}\ S1\ \texttt{else}\ S2}{Q}}
\eproof

\item Sequencing
\sproof
\AxiomC{\hoare{P}{S1}{R}}
\AxiomC{\hoare{R}{S}{Q}}
\BinaryInfC{\hoare{P}{S1\ ;\ S2}{Q}}
\eproof

\item New
\sproof
\AxiomC{$\models P \Rightarrow Q_S$}
\UnaryInfC{\hoare{P}{\texttt{new}\ S}{Q}}
\eproof
where $Q_S$ means that $Q$ holds for the heap in which the value evaluated from $S$ has been allocated.


\end{itemize}

\end{appendices}


\end{document}
