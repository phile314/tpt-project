\documentclass[12pt, a4paper, oneside]{article}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{placeins}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{bussproofs}
\usepackage{xparse}

\usepackage[toc,page]{appendix}

\newcommand{\stepsto}{\Downarrow}

% font size could be 10pt (default), 11pt or 12 pt
% paper size coulde be letterpaper (default), legalpaper, executivepaper,
% a4paper, a5paper or b5paper
% side coulde be oneside (default) or twoside 
% columns coulde be onecolumn (default) or twocolumn
% graphics coulde be final (default) or draft 
%
% titlepage coulde be notitlepage (default) or titlepage which 
% makes an extra page for title 
% 
% paper alignment coulde be portrait (default) or landscape 
%
% equations coulde be 
%   default number of the equation on the rigth and equation centered 
%   leqno number on the left and equation centered 
%   fleqn number on the rigth and  equation on the left side
%   

\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-10mu+}}}

\newcommand{\sproof}{
  \scriptsize
  \begin{center}
  \begin{prooftree}
  \def\defaultHypSeparation{\hskip .1in}
% whats that doing? ->  \def\fCenter{\models}
}

\newcommand{\eproof}{
  \end{prooftree}
  \end{center}
  \normalsize
}

\DeclareDocumentCommand{\sstepe}{m m m m} {%
  \ensuremath{{#1} \vdash \text{{#3}} \; \rightarrow \; {#2} \vdash \text{{#4}}}%
}
\DeclareDocumentCommand{\sstep}{O{} O{} m m} {%
  \sstepe{\Phi_{#1}}{\Phi_{#2}}{#3}{#4}%
}



\title{TPT Project (TODO add desc)}
\author{Marco Vassena  \\
    4110161 \\
    \and
    Philipp Hausmann \\
    4003373 \\
    \and
    Ondra Pelech \\
    F131636 \\
    }

\date{\today}
\begin{document}



\maketitle

\tableofcontents


\section{Research question}

1) Formalize semantics for a minimal programming language with mutable heap and exceptions.

2) Prove meta-theories.


\section{Research contribution}

1) Design and implementation in agda of such language.

2) Formal proofs of progress, preservation, soundness, completeness etc. using agda 

3) Development of an hoare logic on top of it, which allows to reason about the correctness of programs written in this language. 

4) Proofs of the principal hoare logic theorems.

\section{Research Method}

Detour about attempts, failures, lessons learned:

		- Lambda calculus

		Challenges in modeling

			- Total language (valid references)

			- Function applications vs proof objects

			- Statement vs expression (hoare)


\section{Related (and further) Work}

Comparison with mini-languages used in the course.

Extend hoare logic to fully cope with the statement vs expression issue (evaluation changes the heap) 

Complete the missing rules. 

Make the theorems for hoare logic more usable.



\begin{thebibliography}{1}

\bibitem{PV14}
  Wishnu Prasetya.
  \emph{Lecture Notes Program Verification, v2014.0}.

\end{thebibliography}



\begin{appendices}

\section{Small-step Semantics}

\subsection{If then else}
\begin{itemize}

\item
If
\sproof
\AxiomC{\sstep[0][1]{c}{c'}}
\UnaryInfC{\sstep[0][1]{\textbf{if} c \textbf{then} t \textbf{else} e}{\textbf{if} c' \textbf{then} t \textbf{else} e}}
\eproof

\item
IfTrue
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{if} \emph{true} \textbf{then} t \textbf{else} e}{t}}
\eproof

\item
IfFalse
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{if} \emph{false} \textbf{then} t \textbf{else} e}{e}}
\eproof

\item
IfErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{if} \emph{error} \textbf{then} t \textbf{else} e}{\emph{error}}}
\eproof

\end{itemize}


\subsection{Is zero?}
\begin{itemize}

\item
IsZero
\sproof
\AxiomC{\sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{\textbf{iszero} t}{\textbf{iszero} t'}}
\eproof

\item
IsZeroZero
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{iszero} (\emph{num} 0)}{\emph{true}}}
\eproof

\item
IsZeroSucc
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{iszero} (\emph{suc} v)}{\emph{false}}}
\eproof

\item
IsZeroErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{iszero} \emph{error}}{\emph{error}}}
\eproof

\end{itemize}


\subsection{References}
\begin{itemize}

\item
New
\sproof
\AxiomC{\sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{\textbf{new} t} {\textbf{new} t'}}
\eproof

\item
NewVal
\sproof
\AxiomC{t $\equiv$ $\ulcorner$ v $\urcorner$}
\UnaryInfC{\sstepe{\Phi}{\Phi \doubleplus [v]}{\textbf{new} t}{\emph{ref} (\underline{len} $\Phi$)}}
\eproof

\item
Deref
\sproof
\AxiomC{\sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{\textbf{!} t} {\textbf{!} t'}}
\eproof

\item
DerefVal
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{!} (\emph{ref} n)} {$\ulcorner$ \underline{lookup} n $\Phi$ $\urcorner$}}
\eproof

\item
DerefErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{!} \emph{error}} {\emph{error}}}
\eproof


\item
AssLeft
\sproof
\AxiomC{\sstep[0][1]{t$_1$}{t$_1$'}}
\UnaryInfC{\sstep[0][1]{t$_1$ \textbf{:=} t$_2$} {t$_1$' \textbf{:=} t$_2$}}
\eproof

\item
AssRight
\sproof
\AxiomC{\underline{isGoodValue} v ~~ \sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{v \textbf{:=} t} {v \textbf{:=} t'}}
\eproof

\item
AssErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\emph{error} \textbf{:=} t} {\emph{error}}}
\eproof

\item
AssRed
\sproof
\AxiomC{t $\equiv$ $\ulcorner$ v $\urcorner$ ~~ rep : \textbf{Elem} $\Phi$ r}
\UnaryInfC{\sstepe{\Phi}{\text{\underline{replace}}~\Phi~\text{rep v}}
{(\emph{ref} r) \textbf{:=} t}{t}}
\eproof

\item
AssRedErr
\sproof
\AxiomC{$\neg$ \textbf{Elem} $\Phi_3$ r}
\UnaryInfC{\sstep{(\emph{ref} r) \textbf{:=} t} {\emph{error}}}
\eproof

\end{itemize}


\subsection{Sequencing}
\begin{itemize}

\item
Seq
\sproof
\AxiomC{\sstep[0][1]{t$_1$}{t$_1$'}}
\UnaryInfC{\sstep[0][1]{t$_1$ \textbf{$\gg$} t$_2$} {t$_1$' \textbf{$\gg$} t$_2$}}
\eproof

\item
SeqVal
\sproof
\AxiomC{\underline{isGoodValue} t$_1$}
\UnaryInfC{\sstep{t$_1$ \textbf{$\gg$} t$_2$} {t$_2$}}
\eproof

\item
SeqErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\emph{error} \textbf{$\gg$} t} {\emph{error}}}
\eproof

\end{itemize}


\subsection{Try catch}
\begin{itemize}

\item
TryCatch
\sproof
\AxiomC{\sstep[0][1]{t$_1$}{t$_1$'}}
\UnaryInfC{\sstep[0][1]{\textbf{try} t$_1$ \textbf{catch} t$_2$} {\textbf{try} t$_1$' \textbf{catch} t$_2$}}
\eproof

\item
TryCatchSucc
\sproof
\AxiomC{\underline{isGoodValue} t$_1$}
\UnaryInfC{\sstep{\textbf{try} t$_1$ \textbf{catch} t$_2$} {t$_1$}}
\eproof

\item
TryCatchFail
\sproof
\AxiomC{\underline{isError} t$_1$}
\UnaryInfC{\sstep{\textbf{try} t$_1$ \textbf{catch} t$_2$} {t$_2$}}
\eproof

\end{itemize}



\section{Big-step Semantics}

\subsection{Values}

\begin{itemize}

\item
True
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{true} ~$\stepsto$~ $\Phi \vdash$ \emph{vtrue}}
\eproof

\item
False
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{false} ~$\stepsto$~ $\Phi \vdash$ \emph{vfalse}}
\eproof

\item
Num
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{num} m ~$\stepsto$~ $\Phi \vdash$ \emph{vnum} m}
\eproof

\item
Ref
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{ref} r ~$\stepsto$~ $\Phi \vdash$ \emph{vref} r}
\eproof

\item
Error
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{error} ~$\stepsto$~ $\Phi \vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{If then else}

\begin{itemize}

\item
IfTrue
\sproof
\AxiomC{$\Phi_1 \vdash$ c ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vtrue}}
\AxiomC{$\Phi_2 \vdash$ t ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{if} c \textbf{then} t \textbf{else} e ~$\stepsto$~ $\Phi_3 \vdash$ v}
\eproof

\item
IfFalse
\sproof
\AxiomC{$\Phi_1 \vdash$ c ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vfalse}}
\AxiomC{$\Phi_2 \vdash$ e ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{if} c \textbf{then} t \textbf{else} e ~$\stepsto$~ $\Phi_3 \vdash$ v}
\eproof

\item
IfErr
\sproof
\AxiomC{$\Phi_1 \vdash$ c ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{if} c \textbf{then} t \textbf{else} e ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{Is zero?}

\begin{itemize}

\item
IsZeroZ
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vnat 0}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{isZero} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vtrue}}
\eproof

\item
IsZeroS
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vnat (succ} n \emph{)}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{isZero} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vfalse}}
\eproof

\item
IsZeroErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{isZero} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{References}

\begin{itemize}

\item
New
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ v}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{new} t ~$\stepsto$~ $\Phi_2 \doubleplus [v] \vdash$ \emph{vref} (\underline{len} $\Phi_2$)}
\eproof

\item
Deref
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vref} r}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{!} t ~$\stepsto$~ $\Phi_2 \vdash$ \underline{lookup} r $\Phi_2$}
\eproof

\item
DerefErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{!} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\eproof

\item
Ass
\sproof
\AxiomC{rep : \textbf{Elem} $\Phi_3$ r ~~ $\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vref} r}
\AxiomC{$\Phi_2 \vdash$ t$_2$ ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{:=} t$_2$ ~$\stepsto$~ \underline{replace} $\Phi_3$ rep v $\vdash$ v}
\eproof

\item
AssOob
\sproof
\AxiomC{$\neg$ \textbf{Elem} $\Phi_3$ r}
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vref} r}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{:=} t$_2$ ~$\stepsto$~ $\Phi_2$ $\vdash$ \emph{verror}}
\eproof

\item
AssErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{:=} t$_2$ ~$\stepsto$~ $\Phi_2$ $\vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{Sequencing}

\begin{itemize}

\item
Seq
\sproof
\AxiomC{$\neg$ \textbf{isVError} v$_1$ ~~ $\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ v$_1$}
\AxiomC{$\Phi_2 \vdash$ t$_2$ ~$\stepsto$~ $\Phi_3 \vdash$ v$_2$}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{$\gg$} t$_2$ ~$\stepsto$~ $\Phi_3$ $\vdash$ v$_2$}
\eproof

\item
SeqErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{$\gg$} t$_2$ ~$\stepsto$~ $\Phi_3$ $\vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{Try catch}

\begin{itemize}

\item
TryCatch
\sproof
\AxiomC{$\neg$ \textbf{isVError} v$_1$}
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{try} t$_1$ \textbf{catch} t$_2$ ~$\stepsto$~ $\Phi_2$ $\vdash$ v}
\eproof

\item
TryCatchErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{$\Phi_2 \vdash$ t$_2$ ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{try} t$_1$ \textbf{catch} t$_2$ ~$\stepsto$~ $\Phi_3$ $\vdash$ v}
\eproof

\end{itemize}

\end{appendices}


\end{document}
