\documentclass[12pt, a4paper, oneside]{article}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{placeins}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{bussproofs}
\usepackage{xparse}

\usepackage[toc,page]{appendix}

\newcommand{\stepsto}{\Downarrow}

% font size could be 10pt (default), 11pt or 12 pt
% paper size coulde be letterpaper (default), legalpaper, executivepaper,
% a4paper, a5paper or b5paper
% side coulde be oneside (default) or twoside 
% columns coulde be onecolumn (default) or twocolumn
% graphics coulde be final (default) or draft 
%
% titlepage coulde be notitlepage (default) or titlepage which 
% makes an extra page for title 
% 
% paper alignment coulde be portrait (default) or landscape 
%
% equations coulde be 
%   default number of the equation on the rigth and equation centered 
%   leqno number on the left and equation centered 
%   fleqn number on the rigth and  equation on the left side
%   

\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-10mu+}}}

\newcommand{\sproof}{
  \scriptsize
  \begin{center}
  \begin{prooftree}
  \def\defaultHypSeparation{\hskip .1in}
% whats that doing? ->  \def\fCenter{\models}
}

\newcommand{\eproof}{
  \end{prooftree}
  \end{center}
  \normalsize
}

\DeclareDocumentCommand{\sstepe}{m m m m} {%
  \ensuremath{{#1} \vdash \text{{#3}} \; \rightarrow \; {#2} \vdash \text{{#4}}}%
}
\DeclareDocumentCommand{\sstep}{O{} O{} m m} {%
  \sstepe{\Phi_{#1}}{\Phi_{#2}}{#3}{#4}%
}



\title{TPT Project (TODO add desc)}
\author{Marco Vassena  \\
    4110161 \\
    \and
    Philipp Hausmann \\
    4003373 \\
    \and
    Ondra Pelech \\
    F131636 \\
    }

\date{\today}
\begin{document}



\maketitle

\tableofcontents


\section{Research question}
Defining a formal semantics for a small arithmetic language is straightforward. In this project, we aimed to enrich such a minimal programming language with a mutable heap, defining and formalizing its semantics. Adding mutable, global state makes the language impure, which  poses a number of problems and issues, such as threading the heap throughout the evaluation of a term and dealing with invalid references to the heap. 
We managed to solve these problems and reached our goals. Furthermore we have successfully embedded hoare logic in the language, allowing to reason about the correctness of a program written in this minimal programming language.

\subsection{Overview}
In section~\ref{sec:method} we show different alternative approaches to solve the problem and their restrictions. 
In section \ref{sec:cont} we define the formal semantics in Agda for one such approach.
Using the formal semantics, we then will prove some meta theories like preservation, soundness, etc..




\section{Research Method}
\label{sec:method}
Designing a suitable language to study the semantics of a mutable heap is not inherently complex, but influences greatly
the ability to prove things. Therefor the choice of language has to be done careful, and we identified two
major aspects defining any such language.

\subsection{Totality}
The first aspect is whether our language is total or not. A language shall be total if all evalutions
are always guaranteed to succeed. A language is non-total, if the evaluation of a term might fail or not terminate at runtime.

\paragraph{Total version}
Having a total language on one hand simplifies proofs in that it reduces the number of possible evaluations.
On the other hand, it requires that we can guarantee the totality of the language in the proofs. This turned
out to be rather difficult.

This proof can be encoded in Agda by adding a heap description object which we call \emph{shape}. The shape
describes the cells of the heap and can be used to guarantee the success of a heap access. The design
is very similar to the Context/Environment design used in the Simply Typed $\lambda$-Calculus
during the TPT lectures.

One source of problems was finding a suitable encoding of reference-values. To be able to relate the proof
objects stored inside a reference with the current heap, all references need to be indexed over the heap.
As references are part of the value domain, this implies that values need to be
indexed over the heap. While we are not aware of any insurmountable problem caused by this, it leads
to very verbose types in the whole program.

A similar issue occurs when storing references themselves on the heap is allowed. The reference
values on the heap now depend on the heap itself in their proof objects. Due to the different
versions of the heap involved this is unlikely to cause circular dependencies, but it increases
the complexity of the semantics and proofs greatly.
An easy solution to this problem is disallowing references on the heap. How this would influence
the semantics remains an open question.


Due to the complexities shown above, we did not succeed in defining and using a total
language in our setting. We have not found any unsolvable problem which would make
defining a total language impossible, but finding a suitable encoding in Agda
and proving properties of the semantics appears to be a hard problem nonetheless.


-TODO describe problems
-Value-Term conversions
-Refs in Heap?
-Proof propagation?


\paragraph{Partial version}
Using a non-total language on the other hand relieves the burden of guaranteeing totality.
Instead, the concept of failure now needs to be encoded either by defining a partial semantics
or by lifting the partiality to the language itself.

At first we tried to define a partial semantics, which unfortunately turned out to be fairly awkward and non-idiomatic. Proofs are limited only to the succeeding cases, which leads to verbose and error-prone proofs without gaining any benefit. 

Lifting the partiality to the language itself makes the semantics total again.
Handling errors appropriately is then a concern of the final user, which mimics the semantics of most widely used programming languages like C, Java, etc. in this regard.
The terms for the partial heap-approach can be seen in figure \ref{lst:part-term}.

\begin{figure}
\begin{lstlisting}
 new  : forall {ty} -> Term ty -> Term (Ref ty)
 !_   : forall {ty} -> Term (Ref ty) -> Term ty
 _<-_ : forall {ty} -> Term (Ref ty) -> Term ty -> Term ty
 ref  : forall {ty} -> Nat -> Term (Ref ty)
\end{lstlisting}
\caption{Terms for partial heap semantics}
\label{lst:part-term}
\end{figure}


\subsection{Host Language}
The second important choice is what other features apart from the heap itself the language will have. We will call this the \emph{Host Language} in the remainder of this report.


\paragraph{Simply Typed $\lambda$-Calculus}
Our first approach was to add a mutable heap to the Simply Typed $\lambda$-Calculus using a total semantics. We used the semantics discussed during the TPT lectures
as base for this experiment.

The combined complexity of the Simply Typed $\lambda$-Calculus itself together with the totality requirement prevented that a solution could be found in a useful timeframe.
How a partial semantics would work together with Simply Typed $\lambda$-Calculus has not been looked at, but we expect that our work on partial semantics for a simple
boolean/naturals language can be used as inspiration.

For further research we strongly recommend to first solve the problems in a simpler language and extend it later on.

\paragraph{BoolNat}
The BoolNat language contains only boolean expression and natural numbers.

\section{Partial BoolNat language}
\label{sec:boolnat}

TODO









		- Lambda calculus

		Challenges in modeling

			- Total language (valid references)

			- Function applications vs proof objects

			- Statement vs expression (hoare)


\section{Research contribution}
\label{sec:cont}
The language described in~\ref{sec:boolnat} has been implemented in Agda together with a small-step, big-step and denotational semantics.

\subsection{Properties}
\label{sec:metatheories}
The following meta-theories have been proved:
\begin{itemize}
	\item Progress
	\item Preservation
	\item Soundness
	\item Completeness
	\item Determinism
	\item Termination
	\item Type preservation in the heap
	\item Size preservation of the heap
\end{itemize}

Most of them are well-known properties of semantics. Those are proved mainly by case analyses and structural induction. By completeness and soundness follow that the big-step semantics is equivalent to the denotational semantics. At the moment the similar correspondence from small-step semantics and big-step semantics holds only in one direction. Nevertheless we expect it to hold as well, but because of the specific definitions used the proof is overly complicated, although not very interesting.

\paragraph{Type preservation in the heap}
This property states that when a cell of the heap is allocated, the type of the values that can be stored in that cell is fixed and cannot be changed. Although we did not use this property, we believe it could be useful in future work.

\paragraph{Size preservation of the heap}
This simple property states that the heap cannot shrink, but only grow arbitrarily.

3) Development of an hoare logic on top of it, which allows to reason about the correctness of programs written in this language. 

4) Proofs of the principal hoare logic theorems.


\section{Related (and further) Work}

Comparison with mini-languages used in the course.

Extend hoare logic to fully cope with the statement vs expression issue (evaluation changes the heap) 

Complete the missing rules. 

Make the theorems for hoare logic more usable.



\begin{thebibliography}{1}

\bibitem{BP02}
  Benjamin C. Pierce.
  \emph{Types and Programming Languages}

\end{thebibliography}



\begin{appendices}

\section{Small-step Semantics}

\subsection{If then else}
\begin{itemize}

\item
If
\sproof
\AxiomC{\sstep[0][1]{t$_0$}{t$_0$'}}
\UnaryInfC{\sstep[0][1]{\textbf{if} t$_0$ \textbf{then} t$_1$ \textbf{else} t$_2$}{\textbf{if} t$_0$' \textbf{then} t$_1$ \textbf{else} t$_2$}}
\eproof

\item
IfTrue
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{if} \emph{true} \textbf{then} t \textbf{else} e}{t}}
\eproof

\item
IfFalse
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{if} \emph{false} \textbf{then} t \textbf{else} e}{e}}
\eproof

\item
IfErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{if} \emph{error} \textbf{then} t \textbf{else} e}{\emph{error}}}
\eproof

\end{itemize}


\subsection{Is zero?}
\begin{itemize}

\item
IsZero
\sproof
\AxiomC{\sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{\textbf{iszero} t}{\textbf{iszero} t'}}
\eproof

\item
IsZeroZero
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{iszero} (\emph{num} 0)}{\emph{true}}}
\eproof

\item
IsZeroSucc
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{iszero} (\emph{suc} v)}{\emph{false}}}
\eproof

\item
IsZeroErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{iszero} \emph{error}}{\emph{error}}}
\eproof

\end{itemize}


\subsection{References}
\begin{itemize}

\item
New
\sproof
\AxiomC{\sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{\textbf{new} t} {\textbf{new} t'}}
\eproof

\item
NewVal
\sproof
\AxiomC{t $\equiv$ $\ulcorner$ v $\urcorner$}
\UnaryInfC{\sstepe{\Phi}{\Phi \doubleplus \text{[v]}}{\textbf{new} t}{\emph{ref} (\underline{len} $\Phi$)}}
\eproof

\item
Deref
\sproof
\AxiomC{\sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{\textbf{!} t} {\textbf{!} t'}}
\eproof

\item
DerefVal
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{!} (\emph{ref} n)} {$\ulcorner$ \underline{lookup} n $\Phi$ $\urcorner$}}
\eproof

\item
DerefErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{!} \emph{error}} {\emph{error}}}
\eproof


\item
AssLeft
\sproof
\AxiomC{\sstep[0][1]{t$_1$}{t$_1$'}}
\UnaryInfC{\sstep[0][1]{t$_1$ \textbf{:=} t$_2$} {t$_1$' \textbf{:=} t$_2$}}
\eproof

\item
AssRight
\sproof
\AxiomC{$\neg$\underline{isError} v ~~ \sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{v \textbf{:=} t} {v \textbf{:=} t'}}
\eproof

\item
AssErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\emph{error} \textbf{:=} t} {\emph{error}}}
\eproof

\item
AssRed
\sproof
\AxiomC{t $\equiv$ $\ulcorner$ v $\urcorner$ ~~ rep : \textbf{Elem} $\Phi$ r}
\UnaryInfC{\sstepe{\Phi}{\text{\underline{replace}}~\Phi~\text{rep v}}
{(\emph{ref} r) \textbf{:=} t}{t}}
\eproof

\item
AssRedErr
\sproof
\AxiomC{$\neg$ \textbf{Elem} $\Phi$ r}
\UnaryInfC{\sstep{(\emph{ref} r) \textbf{:=} t} {\emph{error}}}
\eproof

\end{itemize}


\subsection{Sequencing}
\begin{itemize}

\item
Seq
\sproof
\AxiomC{\sstep[0][1]{t$_1$}{t$_1$'}}
\UnaryInfC{\sstep[0][1]{t$_1$ \textbf{$\gg$} t$_2$} {t$_1$' \textbf{$\gg$} t$_2$}}
\eproof

\item
SeqVal
\sproof
\AxiomC{$\neg$\underline{isError} v$_1$}
\UnaryInfC{\sstep{v$_1$ \textbf{$\gg$} t$_2$} {t$_2$}}
\eproof

\item
SeqErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\emph{error} \textbf{$\gg$} t} {\emph{error}}}
\eproof

\end{itemize}


\subsection{Try catch}
\begin{itemize}

\item
TryCatch
\sproof
\AxiomC{\sstep[0][1]{t$_1$}{t$_1$'}}
\UnaryInfC{\sstep[0][1]{\textbf{try} t$_1$ \textbf{catch} t$_2$} {\textbf{try} t$_1$' \textbf{catch} t$_2$}}
\eproof

\item
TryCatchSucc
\sproof
\AxiomC{$\neg$\underline{isError} v$_1$}
\UnaryInfC{\sstep{\textbf{try} v$_1$ \textbf{catch} t$_2$} {v$_1$}}
\eproof

\item
TryCatchFail
\sproof
\AxiomC{\underline{isError} t$_1$}
\UnaryInfC{\sstep{\textbf{try} t$_1$ \textbf{catch} t$_2$} {t$_2$}}
\eproof

\end{itemize}



\section{Big-step Semantics}

\subsection{Values}

\begin{itemize}

\item
True
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{true} ~$\stepsto$~ $\Phi \vdash$ \emph{vtrue}}
\eproof

\item
False
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{false} ~$\stepsto$~ $\Phi \vdash$ \emph{vfalse}}
\eproof

\item
Num
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{num} m ~$\stepsto$~ $\Phi \vdash$ \emph{vnum} m}
\eproof

\item
Ref
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{ref} r ~$\stepsto$~ $\Phi \vdash$ \emph{vref} r}
\eproof

\item
Error
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{error} ~$\stepsto$~ $\Phi \vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{If then else}

\begin{itemize}

\item
IfTrue
\sproof
\AxiomC{$\Phi_1 \vdash$ c ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vtrue}}
\AxiomC{$\Phi_2 \vdash$ t ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{if} c \textbf{then} t \textbf{else} e ~$\stepsto$~ $\Phi_3 \vdash$ v}
\eproof

\item
IfFalse
\sproof
\AxiomC{$\Phi_1 \vdash$ c ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vfalse}}
\AxiomC{$\Phi_2 \vdash$ e ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{if} c \textbf{then} t \textbf{else} e ~$\stepsto$~ $\Phi_3 \vdash$ v}
\eproof

\item
IfErr
\sproof
\AxiomC{$\Phi_1 \vdash$ c ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{if} c \textbf{then} t \textbf{else} e ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{Is zero?}

\begin{itemize}

\item
IsZeroZ
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vnat 0}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{isZero} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vtrue}}
\eproof

\item
IsZeroS
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vnat (succ} n \emph{)}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{isZero} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vfalse}}
\eproof

\item
IsZeroErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{isZero} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{References}

\begin{itemize}

\item
New
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ v}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{new} t ~$\stepsto$~ $\Phi_2 \doubleplus$ [v] $\vdash$ \emph{vref} (\underline{len} $\Phi_2$)}
\eproof

\item
Deref
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vref} r}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{!} t ~$\stepsto$~ $\Phi_2 \vdash$ \underline{lookup} r $\Phi_2$}
\eproof

\item
DerefErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{!} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\eproof

\item
Ass
\sproof
\AxiomC{rep : \textbf{Elem} $\Phi_3$ r ~~ $\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vref} r}
\AxiomC{$\Phi_2 \vdash$ t$_2$ ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{:=} t$_2$ ~$\stepsto$~ \underline{replace} $\Phi_3$ rep v $\vdash$ v}
\eproof

\item
AssOob
\sproof
\AxiomC{$\neg$ \textbf{Elem} $\Phi_3$ r}
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vref} r}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{:=} t$_2$ ~$\stepsto$~ $\Phi_2$ $\vdash$ \emph{verror}}
\eproof

\item
AssErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{:=} t$_2$ ~$\stepsto$~ $\Phi_2$ $\vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{Sequencing}

\begin{itemize}

\item
Seq
\sproof
\AxiomC{$\neg$ \textbf{isVError} v$_1$ ~~ $\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ v$_1$}
\AxiomC{$\Phi_2 \vdash$ t$_2$ ~$\stepsto$~ $\Phi_3 \vdash$ v$_2$}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{$\gg$} t$_2$ ~$\stepsto$~ $\Phi_3$ $\vdash$ v$_2$}
\eproof

\item
SeqErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{$\gg$} t$_2$ ~$\stepsto$~ $\Phi_3$ $\vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{Try catch}

\begin{itemize}

\item
TryCatch
\sproof
\AxiomC{$\neg$ \textbf{isVError} v$_1$}
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{try} t$_1$ \textbf{catch} t$_2$ ~$\stepsto$~ $\Phi_2$ $\vdash$ v}
\eproof

\item
TryCatchErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{$\Phi_2 \vdash$ t$_2$ ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{try} t$_1$ \textbf{catch} t$_2$ ~$\stepsto$~ $\Phi_3$ $\vdash$ v}
\eproof

\end{itemize}

\end{appendices}


\end{document}
