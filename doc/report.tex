\documentclass[12pt, a4paper, oneside]{article}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{placeins}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{bussproofs}
\usepackage{xparse}

\usepackage[toc,page]{appendix}

\newcommand{\stepsto}{\Downarrow}

% font size could be 10pt (default), 11pt or 12 pt
% paper size coulde be letterpaper (default), legalpaper, executivepaper,
% a4paper, a5paper or b5paper
% side coulde be oneside (default) or twoside 
% columns coulde be onecolumn (default) or twocolumn
% graphics coulde be final (default) or draft 
%
% titlepage coulde be notitlepage (default) or titlepage which 
% makes an extra page for title 
% 
% paper alignment coulde be portrait (default) or landscape 
%
% equations coulde be 
%   default number of the equation on the rigth and equation centered 
%   leqno number on the left and equation centered 
%   fleqn number on the rigth and  equation on the left side
%   

\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-10mu+}}}

\newcommand{\sproof}{
  \scriptsize
  \begin{center}
  \begin{prooftree}
  \def\defaultHypSeparation{\hskip .1in}
% whats that doing? ->  \def\fCenter{\models}
}

\newcommand{\eproof}{
  \end{prooftree}
  \end{center}
  \normalsize
}

\DeclareDocumentCommand{\sstepe}{m m m m} {%
  \ensuremath{{#1} \vdash \text{{#3}} \; \rightarrow \; {#2} \vdash \text{{#4}}}%
}
\DeclareDocumentCommand{\sstep}{O{} O{} m m} {%
  \sstepe{\Phi_{#1}}{\Phi_{#2}}{#3}{#4}%
}



\title{TPT Project (TODO add desc)}
\author{Marco Vassena  \\
    4110161 \\
    \and
    Philipp Hausmann \\
    4003373 \\
    \and
    Ondra Pelech \\
    F131636 \\
    }

\date{\today}
\begin{document}



\maketitle

\tableofcontents


\section{Research question}
Providing formal semantics for example for a small arithmetic language is straightforward. In this project, we want to define such semantics
for a minimal programming language which has a mutable heap. Adding mutable, global state makes a language no more sideeffect free in
general, which makes the problem harder to solve.

We will first show different approaches possible to solve the problem and their restrictions. We then will define the formal
semantics in Agda for one such approach.


Using the formal semantics, we then will prove some meta theories like preservation, soundness, etc..




\section{Research Method}

Designing a suitable language to study the semantics of a mutable heap is not inherently complex, but influences greatly
the ability to prove things. Therefor the choice of language has to be done careful, and we identified two
major aspects defining any such language.

\subsection{Totality}
The first aspect is whether our language is total or not. A language shall be total if all evalutions
are always guaranteed to succeed. A language is non-total, if an evaluation of a term might fail
at runtime.

\paragraph{Total version}
Having a total language on one hand simplifies proofs in that it reduces the number of possible evaluations.
On the other hand, it requires that we can guarantee the totalness of the language in the proofs. This turned
out to be rather difficult.
-TODO describe problems
-Value-Term conversions
-Refs in Heap?
-Proof propagation?


\paragraph{Partial version}
Using a non-total language on the other hand removes the problem of having to ensure totality.
Instead, the concept of failure now needs to be encoded either by defining a partial semantics
or by lifting the partiality to the language itself.

Lifting the partiality to the language itself makes the language total again, as it is now
the problem of the user of the language to handle errors appropriately. This mimics the semantics
of most widely used programming languages like C, Java, etc. in this regard.



\subsection{Host Language}
\paragraph{BoolNat}
\paragraph{Simply typed $\lambda$-Calculus}








		- Lambda calculus

		Challenges in modeling

			- Total language (valid references)

			- Function applications vs proof objects

			- Statement vs expression (hoare)


\section{Research contribution}


1) Design and implementation in agda of such language.

2) Formal proofs of progress, preservation, soundness, completeness etc. using agda 

3) Development of an hoare logic on top of it, which allows to reason about the correctness of programs written in this language. 

4) Proofs of the principal hoare logic theorems.


\section{Related (and further) Work}

Comparison with mini-languages used in the course.

Extend hoare logic to fully cope with the statement vs expression issue (evaluation changes the heap) 

Complete the missing rules. 

Make the theorems for hoare logic more usable.



\begin{thebibliography}{1}

\bibitem{BP02}
  Benjamin C. Pierce.
  \emph{Types and Programming Languages}

\end{thebibliography}



\begin{appendices}

\section{Small-step Semantics}

\subsection{If then else}
\begin{itemize}

\item
If
\sproof
\AxiomC{\sstep[0][1]{t$_0$}{t$_0$'}}
\UnaryInfC{\sstep[0][1]{\textbf{if} t$_0$ \textbf{then} t$_1$ \textbf{else} t$_2$}{\textbf{if} t$_0$' \textbf{then} t$_1$ \textbf{else} t$_2$}}
\eproof

\item
IfTrue
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{if} \emph{true} \textbf{then} t \textbf{else} e}{t}}
\eproof

\item
IfFalse
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{if} \emph{false} \textbf{then} t \textbf{else} e}{e}}
\eproof

\item
IfErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{if} \emph{error} \textbf{then} t \textbf{else} e}{\emph{error}}}
\eproof

\end{itemize}


\subsection{Is zero?}
\begin{itemize}

\item
IsZero
\sproof
\AxiomC{\sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{\textbf{iszero} t}{\textbf{iszero} t'}}
\eproof

\item
IsZeroZero
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{iszero} (\emph{num} 0)}{\emph{true}}}
\eproof

\item
IsZeroSucc
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{iszero} (\emph{suc} v)}{\emph{false}}}
\eproof

\item
IsZeroErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{iszero} \emph{error}}{\emph{error}}}
\eproof

\end{itemize}


\subsection{References}
\begin{itemize}

\item
New
\sproof
\AxiomC{\sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{\textbf{new} t} {\textbf{new} t'}}
\eproof

\item
NewVal
\sproof
\AxiomC{t $\equiv$ $\ulcorner$ v $\urcorner$}
\UnaryInfC{\sstepe{\Phi}{\Phi \doubleplus \text{[v]}}{\textbf{new} t}{\emph{ref} (\underline{len} $\Phi$)}}
\eproof

\item
Deref
\sproof
\AxiomC{\sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{\textbf{!} t} {\textbf{!} t'}}
\eproof

\item
DerefVal
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{!} (\emph{ref} n)} {$\ulcorner$ \underline{lookup} n $\Phi$ $\urcorner$}}
\eproof

\item
DerefErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\textbf{!} \emph{error}} {\emph{error}}}
\eproof


\item
AssLeft
\sproof
\AxiomC{\sstep[0][1]{t$_1$}{t$_1$'}}
\UnaryInfC{\sstep[0][1]{t$_1$ \textbf{:=} t$_2$} {t$_1$' \textbf{:=} t$_2$}}
\eproof

\item
AssRight
\sproof
\AxiomC{$\neg$\underline{isError} v ~~ \sstep[0][1]{t}{t'}}
\UnaryInfC{\sstep[0][1]{v \textbf{:=} t} {v \textbf{:=} t'}}
\eproof

\item
AssErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\emph{error} \textbf{:=} t} {\emph{error}}}
\eproof

\item
AssRed
\sproof
\AxiomC{t $\equiv$ $\ulcorner$ v $\urcorner$ ~~ rep : \textbf{Elem} $\Phi$ r}
\UnaryInfC{\sstepe{\Phi}{\text{\underline{replace}}~\Phi~\text{rep v}}
{(\emph{ref} r) \textbf{:=} t}{t}}
\eproof

\item
AssRedErr
\sproof
\AxiomC{$\neg$ \textbf{Elem} $\Phi$ r}
\UnaryInfC{\sstep{(\emph{ref} r) \textbf{:=} t} {\emph{error}}}
\eproof

\end{itemize}


\subsection{Sequencing}
\begin{itemize}

\item
Seq
\sproof
\AxiomC{\sstep[0][1]{t$_1$}{t$_1$'}}
\UnaryInfC{\sstep[0][1]{t$_1$ \textbf{$\gg$} t$_2$} {t$_1$' \textbf{$\gg$} t$_2$}}
\eproof

\item
SeqVal
\sproof
\AxiomC{$\neg$\underline{isError} v$_1$}
\UnaryInfC{\sstep{v$_1$ \textbf{$\gg$} t$_2$} {t$_2$}}
\eproof

\item
SeqErr
\sproof
\AxiomC{}
\UnaryInfC{\sstep{\emph{error} \textbf{$\gg$} t} {\emph{error}}}
\eproof

\end{itemize}


\subsection{Try catch}
\begin{itemize}

\item
TryCatch
\sproof
\AxiomC{\sstep[0][1]{t$_1$}{t$_1$'}}
\UnaryInfC{\sstep[0][1]{\textbf{try} t$_1$ \textbf{catch} t$_2$} {\textbf{try} t$_1$' \textbf{catch} t$_2$}}
\eproof

\item
TryCatchSucc
\sproof
\AxiomC{$\neg$\underline{isError} v$_1$}
\UnaryInfC{\sstep{\textbf{try} v$_1$ \textbf{catch} t$_2$} {v$_1$}}
\eproof

\item
TryCatchFail
\sproof
\AxiomC{\underline{isError} t$_1$}
\UnaryInfC{\sstep{\textbf{try} t$_1$ \textbf{catch} t$_2$} {t$_2$}}
\eproof

\end{itemize}



\section{Big-step Semantics}

\subsection{Values}

\begin{itemize}

\item
True
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{true} ~$\stepsto$~ $\Phi \vdash$ \emph{vtrue}}
\eproof

\item
False
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{false} ~$\stepsto$~ $\Phi \vdash$ \emph{vfalse}}
\eproof

\item
Num
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{num} m ~$\stepsto$~ $\Phi \vdash$ \emph{vnum} m}
\eproof

\item
Ref
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{ref} r ~$\stepsto$~ $\Phi \vdash$ \emph{vref} r}
\eproof

\item
Error
\sproof
\AxiomC{}
\UnaryInfC{$\Phi \vdash$ \textbf{error} ~$\stepsto$~ $\Phi \vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{If then else}

\begin{itemize}

\item
IfTrue
\sproof
\AxiomC{$\Phi_1 \vdash$ c ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vtrue}}
\AxiomC{$\Phi_2 \vdash$ t ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{if} c \textbf{then} t \textbf{else} e ~$\stepsto$~ $\Phi_3 \vdash$ v}
\eproof

\item
IfFalse
\sproof
\AxiomC{$\Phi_1 \vdash$ c ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vfalse}}
\AxiomC{$\Phi_2 \vdash$ e ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{if} c \textbf{then} t \textbf{else} e ~$\stepsto$~ $\Phi_3 \vdash$ v}
\eproof

\item
IfErr
\sproof
\AxiomC{$\Phi_1 \vdash$ c ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{if} c \textbf{then} t \textbf{else} e ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{Is zero?}

\begin{itemize}

\item
IsZeroZ
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vnat 0}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{isZero} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vtrue}}
\eproof

\item
IsZeroS
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vnat (succ} n \emph{)}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{isZero} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vfalse}}
\eproof

\item
IsZeroErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{isZero} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{References}

\begin{itemize}

\item
New
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ v}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{new} t ~$\stepsto$~ $\Phi_2 \doubleplus$ [v] $\vdash$ \emph{vref} (\underline{len} $\Phi_2$)}
\eproof

\item
Deref
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vref} r}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{!} t ~$\stepsto$~ $\Phi_2 \vdash$ \underline{lookup} r $\Phi_2$}
\eproof

\item
DerefErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{!} t ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\eproof

\item
Ass
\sproof
\AxiomC{rep : \textbf{Elem} $\Phi_3$ r ~~ $\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vref} r}
\AxiomC{$\Phi_2 \vdash$ t$_2$ ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{:=} t$_2$ ~$\stepsto$~ \underline{replace} $\Phi_3$ rep v $\vdash$ v}
\eproof

\item
AssOob
\sproof
\AxiomC{$\neg$ \textbf{Elem} $\Phi_3$ r}
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{vref} r}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{:=} t$_2$ ~$\stepsto$~ $\Phi_2$ $\vdash$ \emph{verror}}
\eproof

\item
AssErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{:=} t$_2$ ~$\stepsto$~ $\Phi_2$ $\vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{Sequencing}

\begin{itemize}

\item
Seq
\sproof
\AxiomC{$\neg$ \textbf{isVError} v$_1$ ~~ $\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ v$_1$}
\AxiomC{$\Phi_2 \vdash$ t$_2$ ~$\stepsto$~ $\Phi_3 \vdash$ v$_2$}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{$\gg$} t$_2$ ~$\stepsto$~ $\Phi_3$ $\vdash$ v$_2$}
\eproof

\item
SeqErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{}
\BinaryInfC{$\Phi_1 \vdash$ t$_1$ \textbf{$\gg$} t$_2$ ~$\stepsto$~ $\Phi_3$ $\vdash$ \emph{verror}}
\eproof

\end{itemize}



\subsection{Try catch}

\begin{itemize}

\item
TryCatch
\sproof
\AxiomC{$\neg$ \textbf{isVError} v$_1$}
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{try} t$_1$ \textbf{catch} t$_2$ ~$\stepsto$~ $\Phi_2$ $\vdash$ v}
\eproof

\item
TryCatchErr
\sproof
\AxiomC{$\Phi_1 \vdash$ t$_1$ ~$\stepsto$~ $\Phi_2 \vdash$ \emph{verror}}
\AxiomC{$\Phi_2 \vdash$ t$_2$ ~$\stepsto$~ $\Phi_3 \vdash$ v}
\BinaryInfC{$\Phi_1 \vdash$ \textbf{try} t$_1$ \textbf{catch} t$_2$ ~$\stepsto$~ $\Phi_3$ $\vdash$ v}
\eproof

\end{itemize}

\end{appendices}


\end{document}
