-- until Thursday

PH  Split types into Basic/Ref types
PH  Restrict Heap to basic types
MV  Use Maybe for denotational semantics
OP  Adapt BigStep and check if they still work



-- try as far as we get, as time permits
MV  Evaluation function
PH  progress + preservation proof with SmallStep

==========================
DONE:
==========================
PH  Index terms by one Shape
MV  Convert Heap to value data type
MV  Move common functions to a utility module
OP  BigStep semantics (fix issues, see comments, reuse existing proofs etc.)

MV  Remove Aliasing stuff

    Maybe remove isValue proof from heap, instead prove that all insert/replace steps only insert values into the heap


- First use simple BoolNat language with references, port to Lambda calculus later


Order of evaluation:

  apply: reduce lhs until it's a closure, then reduce rhs, then apply

Term: indexed by Shape (and Context for Lambda version)







Since we don't have bindings (variables) it does not make much sense to have
aliasing (just increases the number of rules)

I am still dubious about ref.
Why exactly do we need it? What is the advantage?
If it allows to express something new then it's ok,
but if assuming that the Elem objects are anywhere you need would work
I would probably leave it out.



at latest Wednesday before PV

MV    look at isPrefix stuff
PH    Should we encode Elem proofs in ref
OP    finish missing small step semantics


Primitives 
  Unit
 
See pg 160 - 161
Values
Terms 


References (At the moment contains only unit)
Heap (List) and references are indeces
Context (De Bruijn indeces)

Semantics:
  Small Step
  Big Step
  Denotational Semantics

Based on what he wants us to proof choose the best.

Properties
  Progress - Preservation
  Completness - Soundness

Are they indipendent properties?

Steps:
0) Define datatypes Values Terms Context and Heap [MV]
      Use GADTs to encode only well type terms
   Semantics [PH]
   Prove Properties (Progress - Preservation) [OP]
   
1) General type in references
2) Ask wouter
