-- Remark
I think that storing the proof isValue in the Heap makes everything a little too verbose
I think we would be able to proof that.

Since we don't have bindings (variables) it does not make much sense to have
aliasing (just increases the number of rules)

I am still dubious about ref.
Why exactly do we need it? What is the advantage?
If it allows to express something new then it's ok,
but if assuming that the Elem objects are anywhere you need would work
I would probably leave it out.

at latest Wednesday before PV

MV    look at isPrefix stuff
PH    Should we encode Elem proofs in ref
OP    finish missing small step semantics



- First use simple BoolNat language with references, port to Lambda calculus later


Order of evaluation:

  apply: reduce lhs until it's a closure, then reduce rhs, then apply

Term: indexed by Shape (and Context for Lambda version)












Primitives 
  Unit
 
See pg 160 - 161
Values
Terms 


References (At the moment contains only unit)
Heap (List) and references are indeces
Context (De Bruijn indeces)

Semantics:
  Small Step
  Big Step
  Denotational Semantics

Based on what he wants us to proof choose the best.

Properties
  Progress - Preservation
  Completness - Soundness

Are they indipendent properties?

Steps:
0) Define datatypes Values Terms Context and Heap [MV]
      Use GADTs to encode only well type terms
   Semantics [PH]
   Prove Properties (Progress - Preservation) [OP]
   
1) General type in references
2) Ask wouter
